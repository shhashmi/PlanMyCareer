export const engineeringRoles = [
  'Backend Engineer',
  'Software Engineer',
  'Full Stack Engineer',
  'Principal Engineer',
  'Data Engineer',
  'Architect'
];

export const skillDescriptions: Record<string, string> = {
  'AI Foundations & Mental Models': `For software engineers, understanding AI foundations means developing accurate intuitions about how modern AI systems—particularly large language models—actually work under the hood. This includes grasping concepts like token prediction, context windows, attention mechanisms, and the statistical nature of model outputs without needing to implement these systems yourself. Having the right mental models helps you understand why an AI tool excels at certain tasks (like code completion or pattern matching) while struggling with others (like maintaining state across long interactions or performing precise arithmetic). This foundational knowledge enables you to set appropriate expectations, architect systems that play to AI strengths, and avoid the common pitfall of anthropomorphizing these tools in ways that lead to poor technical decisions. It's the difference between treating AI as magic versus understanding it as a sophisticated but bounded technology with specific capabilities and limitations.`,

  'Prompting & Human-AI Interaction': `Effective prompting for software engineers goes far beyond casual chatbot interactions—it's about systematically communicating requirements, constraints, and context to AI systems in ways that produce reliable, high-quality outputs. This includes mastering techniques like few-shot prompting with code examples, chain-of-thought reasoning for complex debugging scenarios, and structured output formats that integrate cleanly with existing toolchains. Engineers fluent in this area understand how to decompose complex tasks, provide relevant context without overwhelming token limits, and iteratively refine prompts based on output quality. They also recognize when a prompt engineering approach is appropriate versus when fine-tuning, retrieval augmentation, or traditional programming would be more effective. This fluency transforms AI from an occasionally helpful assistant into a predictable, powerful component of your development workflow.`,

  'AI-Augmented Software Engineering': `This fluency encompasses the practical integration of AI tools throughout the software development lifecycle—from design and implementation to documentation and maintenance. Software engineers should understand how to leverage AI pair-programming tools like GitHub Copilot or Cursor effectively, knowing when to accept suggestions, when to guide the AI with comments or partial implementations, and when to write code manually. Beyond code generation, this includes using AI for code review, refactoring legacy systems, generating documentation, translating between programming languages, and explaining unfamiliar codebases. The fluent engineer maintains a healthy skepticism, always reviewing AI-generated code for correctness, security vulnerabilities, and alignment with team standards. They also understand how to structure their projects, write descriptive commit messages, and maintain clear documentation in ways that make AI assistance more effective for the entire team.`,

  'Agentic AI Systems': `Agentic AI represents a paradigm shift from single-prompt interactions to autonomous systems that can plan, execute multi-step tasks, use tools, and adapt based on feedback. For software engineers, fluency here means understanding how to design, implement, and supervise AI agents that can perform complex workflows—whether that's automating deployment pipelines, conducting code migrations, or orchestrating multi-service debugging sessions. This includes familiarity with agent architectures, tool-calling patterns, memory systems, and the critical importance of guardrails and human-in-the-loop checkpoints. Engineers need to understand concepts like ReAct patterns, function calling APIs, and how to design robust fallback behaviors when agents encounter unexpected situations. As AI agents become more capable, knowing how to safely delegate increasing autonomy while maintaining appropriate oversight becomes a critical engineering skill.`,

  'AI-Assisted Debugging & Testing': `Debugging and testing represent some of the highest-leverage applications of AI in software engineering, yet require specific skills to use effectively. This fluency involves using AI to analyze stack traces, identify root causes from error logs, generate hypotheses about bug origins, and suggest targeted fixes. For testing, it encompasses AI-assisted test generation, including edge case identification, property-based test design, and creating comprehensive test suites from specifications or existing code. Engineers fluent in this area know how to provide AI with sufficient context—relevant code snippets, system architecture, reproduction steps—to get actionable debugging assistance rather than generic suggestions. They also understand the limitations: AI can miss subtle race conditions, may not understand your specific infrastructure, and can confidently suggest fixes that introduce new bugs. The skill lies in using AI to accelerate hypothesis generation and test coverage while maintaining rigorous verification practices.`,

  'AI Productivity & Automation': `Beyond code-specific applications, AI fluency extends to automating and streamlining the broader work of software engineering. This includes using AI to draft technical specifications, generate meeting summaries, create runbooks, automate routine communications, and transform rough notes into polished documentation. Engineers should understand how to build personal automation workflows—connecting AI capabilities to email, calendar, project management tools, and development environments through APIs and automation platforms. This fluency also involves recognizing which tasks benefit most from AI automation (repetitive, pattern-based, low-stakes) versus those requiring human judgment (architectural decisions, sensitive communications, novel problem-solving). The goal is developing a personal productivity system where AI handles cognitive busywork, freeing engineers to focus on the creative and strategic aspects of their work that deliver the most value.`,

  'AI Risk, Ethics & Compliance': `Software engineers increasingly need to understand the risk landscape surrounding AI systems they use and build. This fluency covers practical concerns like data privacy when using AI tools (what code or data gets sent to third-party APIs), intellectual property considerations around AI-generated code, and compliance requirements in regulated industries. It also encompasses understanding and mitigating AI-specific risks: model hallucinations that could introduce bugs, training data memorization that could leak sensitive information, and the potential for AI tools to perpetuate or introduce security vulnerabilities. Engineers should be familiar with their organization's AI usage policies, understand when AI assistance is appropriate versus prohibited, and know how to document AI involvement in development processes for audit purposes. This isn't about avoiding AI—it's about using it responsibly while understanding the genuine risks involved.`,

  'AI-Augmented Decision Making': `Software engineers constantly make decisions—technology choices, architectural tradeoffs, prioritization calls—and AI can serve as a powerful analytical partner in these processes. This fluency involves using AI to rapidly research options, synthesize information from documentation and forums, model tradeoffs, and stress-test reasoning. For instance, an engineer might use AI to compare database technologies for a specific use case, generate pros and cons of different architectural approaches, or identify potential failure modes in a proposed design. The key skill is treating AI as a thought partner that can expand your perspective and challenge assumptions, while recognizing that AI may have outdated information, miss domain-specific nuances, or reflect biases in its training data. Fluent engineers use AI to enhance their decision-making process without abdicating their responsibility to exercise judgment and own the outcomes.`,

  'AI Communication & Alignment': `AI becomes central to software development, engineers need skills to communicate effectively about AI capabilities, limitations, and tradeoffs with diverse stakeholders. This includes translating between technical AI concepts and business implications, setting realistic expectations with product managers about what AI features can deliver, and explaining AI behavior to end users in accessible terms. Within engineering teams, this fluency encompasses documenting AI-assisted development processes, establishing shared norms around AI tool usage, and creating feedback loops to continuously improve how the team leverages AI. It also involves the ability to critically evaluate vendor claims about AI products, ask the right questions during tool evaluation, and advocate effectively for appropriate AI investments. Clear communication about AI prevents both over-hyped expectations and unnecessary skepticism, enabling organizations to capture real value.`,

  'AI Tool & Ecosystem Literacy': `The AI tooling landscape evolves rapidly, and software engineers need frameworks for evaluating, adopting, and staying current with relevant tools without succumbing to every new trend. This fluency includes understanding the major categories of AI tools relevant to software engineering—code assistants, chat interfaces, specialized agents, embedding models, local versus cloud options—and their respective strengths and integration points. Engineers should know how to evaluate tools against criteria like accuracy, latency, cost, privacy, and workflow integration. They should understand the ecosystem of APIs, SDKs, and platforms that enable building AI-powered features into their own applications. Crucially, this fluency includes developing efficient learning strategies: knowing which sources to follow, how to quickly prototype with new tools, and how to distinguish genuinely useful innovations from hype. The goal isn't encyclopedic knowledge of every tool, but the ability to rapidly assess and adopt the right tools when needed.`
};
